var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [ParallelMaximumClique]","category":"page"},{"location":"reference/#ParallelMaximumClique.maximum_clique!-Tuple{Vector{Int32}, Vector{Int32}, Vector{Int32}}","page":"Reference","title":"ParallelMaximumClique.maximum_clique!","text":"int K = maximum_clique!(ouput::Vector{Int32}, ei::Vector{Int32}, ej::Vector{Int32}; \n    verbose=0; \n    algorithm=0; \n    time_limit_secs=3600.0;\n    remove_time_secs=4.0)\n\nInputs:\n\nei: the vector of edge sources\nej: the vector of edge destinations\n\nOutputs:\n\nK: the maximum clique size\noutput: the vector containing a list of nodes in the maximum clique (modified in-place)\n\nParameters:\n\nverbose: set to positive integer to print additional debug statements\nalgorithm: choose between {0,1,2}\ntime_limit_secs: maximum compute time\nremove_time_secs: maximum time before the graph gets reduced.\n\nNotes:\n\nfor an edge to be valid, ei[k] > ej[k] for all k.\nonly the first K elements of output are modified.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParallelMaximumClique.maximum_clique-Tuple{SparseArrays.SparseMatrixCSC}","page":"Reference","title":"ParallelMaximumClique.maximum_clique","text":"maximum_clique(A::SparseMatrixCSC; normalize=true, kwargs...)\n\nreturns a Vector{Int32} of the nodes in the maximum clique of g, where A is the adjacency matrix of g. \n\nall kwargs are passed to maximum_clique!\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParallelMaximumClique.maximum_clique-Union{Tuple{G}, Tuple{T}} where {T, G<:Graphs.AbstractGraph{T}}","page":"Reference","title":"ParallelMaximumClique.maximum_clique","text":"maximum_clique(g::G; kwargs...) where {T, G<:AbstractGraph{T}}\n\nreturns a Vector{Int32} of the nodes of g that are in the maximum clique in g\n\nall kwargs are passed to maximum_clique!\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParallelMaximumClique.normalize!-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T","page":"Reference","title":"ParallelMaximumClique.normalize!","text":"normalize!(A<:AbstractMatrix)\n\nreplaces each non-zero element of A with a 1.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParallelMaximumClique.normalize!-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}","page":"Reference","title":"ParallelMaximumClique.normalize!","text":"normalize!(A::SparseMatrixCSC)\n\nreplaces each non-zero element of A with a 1.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = ParallelMaximumClique","category":"page"},{"location":"#ParallelMaximumClique","page":"Home","title":"ParallelMaximumClique","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for ParallelMaximumClique.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package wraps dev10110/pmc (that is a fork of ryanrossi/pmc) as a Julia library.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Simply ","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add https://github.com/dev10110/ParallelMaximumClique.jl","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Minimal Example, using Graphs.jl interface","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Graphs, ParallelMaximumClique\n\n# construct a graph\ng = barabasi_albert(100, 25)\n\n# determine the nodes in the maximum clique\nclique = maximum_clique(g)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Alternatively, provide a sparse adjacency matrix:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using ParallelMaximumClique, SparseArrays\n\n# construct the adjacency matrix\nA = adjacency_matrix(...)\n\nclique = maximum_clique(sparse(A))","category":"page"},{"location":"","page":"Home","title":"Home","text":"There is a more low-level interfance described in the reference page. Optional arguments are also described there. ","category":"page"},{"location":"#Licence/Citation","page":"Home","title":"Licence/Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"All credit for this package goes to the original authors. I, Dev, have simply wrapped it into a Julia library.  As per the original terms and conditions:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Terms and conditions\nPlease feel free to use these codes. We only ask that you cite:\n\nRyan A. Rossi, David F. Gleich, Assefaw H. Gebremedhin, Md. Mostofa Patwary,  \nA Fast Parallel Maximum Clique Algorithm for Large Sparse Graphs and Temporal  \nStrong Components, arXiv preprint 1302.6256, 2013.  \nThese codes are research prototypes and may not work for you. No promises. But do email if you run into problems.\n\nCopyright 2011-2013, Ryan A. Rossi. All rights reserved.","category":"page"},{"location":"#Gotchas","page":"Home","title":"Gotchas","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In the process of making this a Julia library, I've had to make it single-threaded, to avoid the use of OpenMP. That said, the library is stil incredibly quick. \nThis library has not been extensively tested. In the words of Rossi: These codes are research prototypes and may not work for you. No promises. But do email if you run into problems.\nThere is much more functionality in the original repo. If you want more functionality exposed, email me at devansh@umich.edu, and I'll modify my fork to expose more of the functions. ","category":"page"}]
}
